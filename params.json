{"name":"Unparse","tagline":"pythonic parsing","body":"## UnParse ##\r\n\r\nAnother parser combinator library for Python?  Don't we have enough of those already???\r\n\r\nThat depends on what we want out of a parser library.  My preferences are for parsers that:\r\n\r\n - simple and clear definition of the parse model:\r\n   - inputs\r\n   - outputs\r\n   - backtracking\r\n   - (non)-deterministic \r\n   - prioritized choice\r\n \r\n - no magic.  Magic operators are often convenient, but it's more important -- \r\n   and useful in the long run -- to be able to easily implement the magic in\r\n   terms of the model.\r\n\r\n - doesn't hide important details -- but also doesn't force you to worry about\r\n   them unless you need to.\r\n\r\n - provides not just complex parsers, but also the primitive.  What are the most \r\n   basic parsers, out of which bigger ones are built?  \r\n \r\n - make parser composition easy.  This means there needs to be\r\n   powerful operations for combining parsers, such as sequencing, monadic \r\n   sequencing, choice, and repetition.\r\n \r\n - doesn't treat lexing as a special case.  Lexing is no different from any\r\n   other kind of parsing, except for the complexity of the language (sometimes).\r\n\r\n - compositional semantics.  Parser behavior should be consistent -- it must not\r\n   depend on what context the parser is in.\r\n \r\n - works with the language, not against it.  Parsers should be able to take \r\n   advantage of a language's features and capabilities for abstraction -- \r\n   including functions and objects.  This means that it's easy to create new\r\n   parsers, as well as combinators, using the language's facilities.\r\n\r\n - the result value of a successful parser is important.  I want full control\r\n   over what value is generated.  I don't want a default parse tree crammed with\r\n   tons of useless junk.  I don't want a mess of nested tuples.  Generating the\r\n   result should be clean and simple.\r\n\r\n - errors are a key aspect of useful parsers.  How and when are they created,\r\n   and with what information (position, message explaining the reason)?  Once\r\n   an error is created, how is it propagated?  How do errors interact with the\r\n   parse model -- backtracking -- and with parser composition?\r\n\r\nThese are the issues that UnParse addresses and that differentiate it from\r\nother parser libraries.  Read on for more information!\r\n \r\n\r\n## Overview ##\r\n\r\nUnParse is a library for building complex parsers.  Parsers are created and\r\nmanipulated as Python objects, and are invoked using their `parse` method,\r\nwhich takes two arguments:\r\n\r\n - the token sequence that is being parsed\r\n - the parsing state\r\n\r\nThe return value is one of three possible results:\r\n\r\n - success, including:\r\n    - the remaining tokens\r\n    - new state\r\n    - result value\r\n - failure, which indicates that the match failed\r\n - error, which means that something bad happened and includes error information\r\n\r\nSuccessful parses allow parsing to continue; failures allow parsing to backtrack\r\nand try a different alternative; errors abort parsing immediately with relevant\r\nerror information to accurately indicate what and where the problem was.\r\n\r\nUnParse supports monadic parsing, as well as combinators based on the Applicative,\r\nFunctor, MonadError, Alternative, and Traversable typeclasses, if you're familiar\r\nwith Haskell.  It also supports lookahead and optional parses.  \r\n\r\nBest of all, since parsers are ordinary Python objects, they play by the rules --\r\nyou don't need any special knowledge or syntax to use them, they work just fine\r\nwith functions and classes, and you can put them in data structures.\r\n\r\nUnParse avoids magic -- the kind of magic that makes it easy to do really simple\r\nthings, but hard to deal with actual real-world problems in a clean, sane way.\r\nThis allows UnParse to stay simple and focused -- and you don't need to worry \r\nabout it mucking with things behind your back -- and free of arbitrary restrictions.\r\n     \r\n\r\n### Contact information ###\r\n\r\nFound a bug?  Need help figuring something out?  Want a new feature?  Feel free\r\nto report anything using the github issue tracker, or email me directly at\r\nmfenwick100 at gmail dot com\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}